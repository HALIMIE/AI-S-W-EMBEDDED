# 250107

생성자: 하 
생성 일시: 2025년 1월 7일 오전 9:31
태그: LINUX

umask → 파일 생성시 특정 접근 권한을 비활성화함

8진수 출력

grep 다용도로 활용되는 파일 검색 명령 한줄한줄

$ grep root /etc/passswd  “root”를 포함한 행 출력

glob 문자 

*

ls /etc/sy*    sy,sys,system 과 같이 모든 조합의 문자열 

?

정확히 한개의 문자로 대체

[ ]

내부에 기록된 문자중 한개가 선택됨

ls /etc/ss[a-zA-Z]

ls /etc/ss[0-9X]

## 표준 입출력과 리다이렉션

>, >>

ls -l > ls.txt 표준 입력 대신 ls.txt 사용

grep conf /etc/* >conf.txt  정상은 conf.txt로, 에러는 화면으로 

grep conf /etc/*  > conf.txt 2> error.txt  정상은 conf.txt로 에러는 error.txt로

grep conf /etc/* >all.txt 2>&1 모든 결과를 all.txt로 2>&1은 에러를 정상과 같은 파일로 출력하라는 의미

grep conf/ etc/* &> all.txt 위 명령과 같은 말

## 파이프 사용 |

$ls -l /etc |  grep conf               conf를 포함한 애를 찾아서 보기 

cat 파일 내용 

ls 파일 이름

# 리눅스 필수 명령어

tar 아카이브 생성 및 해제 , 아카이브 압축 및 해제 

$ tar -cvf testdir.tar testdir            testdir 를 아카이브로 만듬

$ tar -xvf testdir.tar        아카이브 해제

$ tar -cvf abc.tar aaa bbb ccc 파일 여러개를 아카이브로 만듬

$date     Wed Jan  8 05:25:22 PM KST 2025 날자 시간 표시

$date “+%Y/%m/%d %H:%M:%S”

            +포멧이나온다 

$ sleep

## **$ find [검색 경로] [조건 표현식] -exec [명령어] {} \;**

$ find /var/log -name *.log -exec cat {} \;

/var/log 에서  이름이 .log 로 끝나는 파일을 검색해서
cat 화면에 출력해줘

/home/user 에서 .conf 로 끝나는 파일 내용을 출력해라

**$ find /home/user -name *.conf -exec cat {} \;**

/home/user 에서 .conf 로 끝나는 파일 내용을 출력해라

**$ find /home/user -name *.conf -exec cat {} \;**

home/user 에서 7일 내에 수정된 파일을 삭제해라

**$ find /home/user -mtime-7 -exec rm {} \;**

### sort 명령

$sort /etc/passwd 사전순으로 저파일의 행을 정렬

### tee 명령

$tee my.txt  표준입력으로 읽어 출력하고 txt에 저장 

cat이랑 같은데 저장 기능이 추가 

$ls /etc | tee etc.txt              etc의 모든 파일을 출력하고 txt에 저장 

### uniq 명령      중복은 하나만 출력

$ cat /etc/profile | sort | uniq                프로파일의 행을 사전순으로 출력하고 중복되는 것은 하나만 출력

### tr 명령 translate

표준입력으로 받아서 문자를 제거하거나 변경 후에 표준 출력으로 출력

$echo “abcdeFGHI” | tr -d cdg                   -d 는 삭제 결과값은 abeFGHI

$echo “abcde” | tr a-z A-Z          ABCDE

### wc 명령

파일 내의 행수,단어수,바이트 수 출력

-l : 행수             -w : 단어수            -c:바이트 수 

$ wc /etc/passwd 행수,단어수,바이트수 순서대로 출력 ex) 

49   88 2929 /etc/passwd

$ ls /etc | wc -l         etc의 모든 파일 수 출력

### cut 명령

구분자로 구분된 행의 특정 필드 추출

$ date | cut -d ‘ ’ -f4

-d 구분자

$cat /etc/passwd | cut -d ‘ :’ -f1,3

$date | cut -d ‘ ’ -f5 | cut -d ‘:’ f1,2

# 파일 시스템

/ 루트 파일 시스템 

리눅스의 **루트 파일시스템**은 리눅스 운영체제에서 모든 파일과 디렉토리의 시작점이 되는 최상위 디렉토리 구조. 리눅스 시스템의 파일과 데이터가 어떻게 구성되고 정리되어 있는지를 보여주는 "뼈대"

---

### **루트 파일시스템의 개념**

- 루트 파일시스템은 `/` (슬래시)로 표시되는 최상위 디렉토리를 기준으로 하는 파일 계층 구조입니다.
- 모든 파일, 디렉토리, 장치, 그리고 네트워크 자원은 이 `/` 아래에 배치
- `/home`, `/bin`, `/usr` 등은 루트 파일시스템 안에 있는 디렉토리들

---

### **왜 루트 파일시스템이 중요한가**

- **운영체제의 기본:** 리눅스가 부팅되면 커널이 가장 먼저 루트 파일시스템을 마운트하여 필요한 파일과 프로그램에 접근합니다.
- **파일 계층 구조:** 루트 파일시스템은 리눅스에서 파일과 디렉토리를 계층적으로 정리하여 사용자가 데이터를 관리하기 쉽게 만들어 줍니다.
- **표준화된 구성:** 리눅스의 파일 계층 구조는 대부분의 배포판에서 표준화되어 있어, 이를 통해 소프트웨어가 어디에 무엇이 있는지 쉽게 찾을 수 있다.

---

### **루트 파일시스템의 주요 디렉토리**

루트 파일시스템의 주요 디렉토리와 그 역할

| 디렉토리 | 역할 |
| --- | --- |
| `/` | 루트 파일시스템의 최상위 디렉토리. 모든 파일과 디렉토리의 시작점. |
| `/bin` | 기본 명령어가 들어있는 디렉토리 (예: `ls`, `cp`, `mv` 등). |
| `/sbin` | 시스템 관리용 명령어가 들어있음 (예: `reboot`, `fsck`). |
| `/etc` | 시스템 설정 파일들이 위치 (예: 네트워크 설정, 사용자 정보). |
| `/home` | 사용자 계정별로 개인 데이터를 저장하는 공간. |
| `/root` | 시스템 관리자(root 계정)의 홈 디렉토리. |
| `/usr` | 추가 소프트웨어와 사용자 프로그램이 설치되는 디렉토리. |
| `/var` | 로그 파일, 캐시 데이터, 메일 등이 저장되는 디렉토리. |
| `/tmp` | 임시 파일이 저장되는 디렉토리. 시스템 재부팅 시 파일 삭제. |
| `/dev` | 시스템의 장치 파일이 위치 (예: 하드디스크, USB 등). |
| `/proc` | 시스템과 프로세스 정보가 저장되는 가상 파일시스템. |
| `/sys` | 시스템 하드웨어 및 커널 정보를 제공하는 가상 파일시스템. |
| `/lib` | 필수 라이브러리 파일이 들어있음. |

---

### **루트 파일시스템의 동작 과정**

1. **부팅 시 마운트:** 리눅스 커널이 부팅되면서 루트 파일시스템을 마운트하여 시스템이 작동할 수 있도록 준비합니다.
2. **파일 계층을 통해 접근:** 프로그램, 설정 파일, 사용자 데이터 등이 `/` 아래의 디렉토리로 계층적으로 접근됩니다.
3. **표준 파일시스템 계층구조 (FHS):** 리눅스는 FHS(Filesystem Hierarchy Standard)를 따르며, 이로 인해 모든 배포판에서 유사한 구조를 유지합니다.

---

### **루트 파일시스템과 마운트**

리눅스에서는 다른 디스크나 파티션을 루트 파일시스템의 특정 디렉토리에 **마운트**하여 사용하는 방식으로 파일 시스템을 확장예를 들어:

- `/home` 디렉토리에 별도의 하드디스크를 마운트하면, 사용자 데이터는 해당 디스크에 저장
- 네트워크 드라이브도 `/mnt` 또는 `/media`에 마운트하여 사용할 수 있다

---

### **쉽게 비유하자면:**

- **루트 파일시스템은 나무의 뿌리(root):** 모든 가지(디렉토리)는 뿌리에서 시작되며 서로 연결되어 있다.
- **파일시스템은 도서관:** `/`은 도서관의 중앙 카탈로그처럼 모든 자료가 어디에 있는지 알려주는 시작점.

---

### **정리**

리눅스 루트 파일시스템은 리눅스 운영체제의 "중추"이며, 파일과 디렉토리를 효율적으로 관리할 수 있게 해주는 구조입니다. 사용자가 파일을 탐색하거나 명령을 실행할 때, 루트 파일시스템은 이를 어떻게 처리할지 안내하는 역할을 합니다.

$df  마운트 되어 있는 디스크 정보를 출력

### mount 명령

파일 시스템을 마운트 (활성화)

$ mount [-t 파일시스템 종류] [장치 이름] [마운트 포인트]

마운트 성공 여부는 $df 로 확인

umount 명령

$ sudo umount /mnt   마운트 포인트를 이용해 언마운트하거나

$ sudo umount /dev/sdb1  장치 이름을 이용해 언마운트

### mkfs 포멧 명령

mkfs **MaKe FileSystem**

언마운트 상태에서 포맷해야함

$ mkfs -t ext2 /dev/sdb1

$dd 지정한 바이트 단위로 파일 복사

$ dd if=/dev/zero of=myimg count=1024 bs=512

if 표준입력대신 of 표준출력대신 count 1024 번 읽는다 bs 512바이트씩 

myimg 의 파일 크기 1024 * 512      512KB

# VI 편집기

복사 y 계열

붙여넣기 p 

글자삭제 x 

행삭제 d 계열

입력 모드 i

undo u 

undo 반대 ctrl + r 

검색 /pattern 
저장 :w 

저장 종료 ZZ

:q! 저장없이 강제종료 

:q  

## #!bin/bash

#! shebang 스크립트 실행할 프로그램 지정

### 쉘스크립트 디버깅

set -x

실행한 명령을 출력한다 

종료하려면 

set+x

# shell script 변수

name=”linux”     공백이 있으면 안된다 문법

echo $name        결과값 linux

echo ${name}         중괄호가 있어도 $name 과 같은 말 

### 특수기능문자 \을 이용

var = \$USER       $USER 대입

var= \\$USER      \user 대입

var = \”$USER \”  “user” 대입

` ` 백틱 

명령의 결과로 인식됨 

var = `date +%F` 2025-01-08 대입

 

# 변수 내보내기

$export name 

변수 내보내기 기능

현재 쉘에서 만든 변수는 지역변수이고 export를 하면 환경변수가 된다

$ set 지역변수와 환경변수 전부 출력

$ env 환경변수만 출력 

$ unset 변수 지우기 

$unset PATH 하면 변수 PATH를 제거해서 

echo $PATH를 하면 에러가 나지만 다른 쉘로 이동한다면 에러가 나지않는다 왜냐하면 쉘끼리는 서로 환경변수 영향을 안주기 떄문이다

주요 환경 변수 

HOME 현재 사용자 현재 디렉터리 

PATH 실행할 명령을 찾는 디렉토리 목록 

USER 사용자 이름

PWD 현재 디렉토리 print working directory

### SOURCE 명령

자식 .sh 스크립트에서 변수 설정해주고 

./ [자식.sh](http://자식.sh) 해도 

$echo $아까만든 변수 해도 안나온다 

source ./자식.sh 하거나

. ./자식.sh 하거나 

. [자식.sh](http://자식.sh) 해서 

sourece 명령으로 스크립트 실행해야지 현재 쉘에 아까만든 변수들이 존재하게 된다. 

환경변수로 만든 변수 있으면 

env | grep 변수

 로 확인해보면 변수 = 설정한값

으로 출력된다.

소스를 안쓰면 부모는 자식쉘이 하는 일에 상관이 없다.

 

### 특수변수

$# 명령 제외하고 넘어온 인자와 옵션의 개수 

./var.sh one two 

입력하면 echo $# 에는 2가 출력된다.

$0에는 명령이 들어간다 

echo $0 에는 ./var.sh 가 출력된다.

$1에는 옵션과 인자를 순서대로 저장하기떄문에

$1에는 one 

$2에는 two 가 들어간다

$$ 에는 현재 프로세스의 아이디 ex)85021 가들어가고 

$?에는 직전명령의 리턴값이 들어가기떄문에 전 명령이 성공했으면 0이 들어가고 

오류메시지 출력 시에는 2가들어가고 

exit 19 를 수행하고 나왔으면 

$?의 값은 19로나온다 

그후에도 성공했으면 0

### 

# 조건문

test 명령은 참 이면 0 거짓이면 1을 반환한다 c랑 다르다

$는 변수의 값 출력

var=75 

test $var -gt 100                  -gt는 greater then 더 크냐는 뜻이다

거짓이니깐 

echo $? 1출력 

test 명령은 [ ]이렇게도 쓰인다 

[ $var -gt 100 ] 대괄호 안에 한칸씩 공백은 줘야한다 

[ ]; echo $? 1

[ abs ]; echo $? 0

[ && ]

[  ||  ] 이렇게도 쓸수있고 

[ ]&&————- 참이면 &&뒤 수행

 [ ] || ————— 거짓이면 || 뒤에 수행

[ ]&&——-|| ——— 참 이면 &&뒤 수행 거짓이면 || 뒤수행

## if 문

if CONTROL-COMMAND

then

COMMAND

fi

if [ -f /etc/issue ]

then echo “exist”

fi

if grep root /etc/passwd > /dev/null 2>&1

then echo ”found”

fi

exist

found 가 나옴

         grep은 값을 찾을 경우에 0을 반환 못찾으면 1을 리턴